module myTaxiService

//----------------BASIC DATA TYPES-------------------
sig Date {
	
	isAtLeastTwoHoursBefore : set Date
}

fact antiReflexive {

	no x: Date | x in x.isAtLeastTwoHoursBefore
}

fact antiSymmetry {

	no x: Date, y:Date | y in x.isAtLeastTwoHoursBefore and x in y.isAtLeastTwoHoursBefore
}

fact transitivity {

	isAtLeastTwoHoursBefore = ^isAtLeastTwoHoursBefore
}
//--------------------------------------------------------

//----------------STATE DEFINITION-------------------
abstract sig State {}
one sig FREE extends State {}
one sig BUSY extends State {}

abstract sig RequestState {}
one sig PENDING extends RequestState {}
one sig CLOSED extends RequestState {}

abstract sig LoginState {}
one sig LOGGED_IN extends LoginState {}
one sig LOGGED_OUT extends LoginState {}
//--------------------------------------------------------

//----------------------------------CLASS DEFINITION------------------------------------------------------
abstract sig Person {

	hasLoginState : one LoginState
}

sig Passenger extends Person {
	
	requests : set TaxiService
}

sig TaxiDriver extends Person {
	
	hasState : one State,
	isDriving : lone Taxi ,
	accepts : set Request
}

sig Taxi {

	isLocated : one Location
}

sig Location {

	belongsTo : one Zone
}

sig Zone {

	hasQueue : one Queue
}

sig Queue {

	contains : some Taxi
}

abstract sig TaxiService {

	hasMeetingPoint : one Location,
	generates : one Request
}

sig TaxiCall extends TaxiService {}

sig TaxiReservation extends TaxiService {

	hasDestination : one Location,
	hasMeetingTime : one Date,
	hasSubmitTime : one Date
}

sig Request {
	
	hasRequestState : one RequestState
}


//---------------------------------------------------------------------------------------------------------------------

//------------------------------------------CARDINALITY FACTS--------------------------------------------------

//No more than one driver for each taxi
fact singleDriver {

	isDriving in TaxiDriver lone -> Taxi
}

//Each zone contains at least one location
fact zoneHasLocation {

	belongsTo in Location some -> Zone
}

//Each queue has exactly one zone
fact oneZone {

	hasQueue in Zone one -> Queue
}

//Each taxi is contained in at most one queue
fact taxiQueue {
	
	contains in Queue lone -> Taxi
}

//Each request is accepted by exactly one taxi driver
fact requestAccepted {

	accepts in TaxiDriver lone -> Request
}

//Each TaxiService is requested by exactly one pasenger
fact singleAuthor {

	requests in Passenger one -> TaxiService
}

//Each request is generated by exactly one TaxiService
fact singleRequest {

	generates in TaxiService one -> Request
}

//--------------------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------FACTS--------------------------------------------------------------------

//A taxi is in a queue if, an only if, it is being driven by a taxi driver, who is free.
fact taxiInAQueue {
	
	all t:Taxi | all q:Queue | t in q.contains implies (some d:TaxiDriver | t in d.isDriving and d.hasState in FREE)
	all t:Taxi | (some d:TaxiDriver | t in d.isDriving and d.hasState in FREE) implies (some q:Queue | t in q.contains)
	all t:Taxi | all q:Queue | t in q.contains implies (q in t.isLocated.belongsTo.hasQueue) 
}

//If a driver is logged out her state is BUSY and no taxi is associated
fact driverLogOut {

	all d:TaxiDriver | d.hasLoginState in LOGGED_OUT implies (d.hasState in BUSY and d.isDriving = none)
}

//If a driver is logged in, she has a taxi associated
fact driverLogIn {

	all d:TaxiDriver | d.hasLoginState in LOGGED_IN implies (some d.isDriving)
}

//The submit time of a reservation is always at least 2 hours before the meeting time
fact reservationTime {

	all r:TaxiReservation | r.hasMeetingTime in r.hasSubmitTime.isAtLeastTwoHoursBefore
}

//A request is closed if, and only if, it has been accepted by a taxi driver
fact acceptedRequest {

	all r:Request | r.hasRequestState in CLOSED iff (some d:TaxiDriver | r in d.accepts)
}

//Meeting point and destination of a reservation never coincide
fact {

	all r:TaxiReservation | r.hasMeetingPoint not in r.hasDestination and r.hasDestination not in r.hasMeetingPoint
}
//------------------------------------------------------------------------------------------------------------------------------------

//----------------------------------------------CARDINALITY ASSERTIONS-----------------------------------------------------
assert singleDriver {
	
	no disj d1,d2: TaxiDriver | some t: Taxi | t in d1.isDriving and t in d2.isDriving
}

check singleDriver

assert zoneHasLocation {

	no z: Zone | #z.(~belongsTo)=0
}

check zoneHasLocation

assert oneZone {

	no q: Queue | some disj z1,z2: Zone | q in z1.hasQueue and q in z2.hasQueue
	no q:Queue | no z:Zone | q in z.hasQueue
}

check oneZone

assert taxiQueue {
	
	no disj q1,q2: Queue | some t: Taxi | t in q1.contains and t in q2.contains
}

check taxiQueue

assert requestAccepted {

	all r:Request | lone d:TaxiDriver | r in d.accepts
}

check requestAccepted

assert singleAuthor {

	no t: TaxiService | some disj p1,p2: Passenger | t in p1.requests and t in p2.requests
	no t:TaxiService | no p:Passenger | t in p.requests
}

check singleAuthor

assert singleRequest {

	no r: Request | some disj t1,t2: TaxiService | r in t1.generates and r in t2.generates
	no r:Request | no t:TaxiService | r in t.generates
}

check singleRequest

//-------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------ASSERTIONS-----------------------------------------------
assert taxiInAQueue {

	no t:Taxi | some q:Queue | t in q.contains and (no d:TaxiDriver | t in d.isDriving)
	no t:Taxi | some q:Queue | some d:TaxiDriver | t in q.contains and t in d.isDriving and d.hasState not in FREE
}

check taxiInAQueue

assert reservationTime {

	no r:TaxiReservation | r.hasMeetingTime not in r.hasSubmitTime.isAtLeastTwoHoursBefore
}

check reservationTime

assert acceptedRequest {
	no r: Request | r.hasRequestState in CLOSED && (no t: TaxiDriver | r in t.accepts)
	no r: Request | r.hasRequestState in PENDING && (some t: TaxiDriver | r in t.accepts) 
}

check acceptedRequest
//-------------------------------------------------------------------------------------------------------------------

pred show{}

pred interestingWorld {
	some TaxiService
	all l: Location | #l.(~isLocated)<=1
	no l:Location | some t:Taxi, s:TaxiService | l in t.isLocated && l in s.hasMeetingPoint
	no p: Person | p.hasLoginState in LOGGED_OUT
}

pred callScenario {
	interestingWorld 
	no TaxiReservation
	one TaxiCall
}

pred reservationScenario {
	interestingWorld 
	one TaxiReservation
	no TaxiCall
}

run callScenario for 2

run reservationScenario for 2

run show

